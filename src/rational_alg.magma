//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//				Computing isomorphism to a matrix algebra over K [2]				//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Ofi is a maximal Fq[x]-order in A, Oinf is a maximal R-order in A.
This function returns a Fq-basis of their intersection, and the structure constants for this intersection as a Fq-algebra
This subroutine implements an algorithm given by lemma 25 in [2]*/

/*Returns a list of length d containing the d lowest degree (possibly zero) coefficients of P*/
coefficientsUpTo:=function(P,d)
	if P eq 0 then
		return [0: _ in [1..d]];
	end if;
	return (Coefficients(P) cat [0: _ in [0..d-Degree(P)]])[1..d];
end function;

rebaseOfi:=function(Ofi,nA,phi)
	M:=Matrix([Coordinates(nA,phi(e)): e in Basis(Ofi)]);
	reduceRatLatBase(~M);
	return Order(R,[nA!ElementToSequence(M[i]): i in [1..Dimension(nA)]]);
end function;
	
/*given ci and cj elements of the reduced basis of Ofi, expresses their product in the F-basis of Ofi \cap Oinf*/
cicjInC:=function(Ofi,i,j,norms,goodIndices)
	p:=Basis(Ofi)[i]*Basis(Ofi)[j];
	coords:=Coordinates(Ofi,p);
	coordsInC:=&cat[coefficientsUpTo(R!coords[k],-norms[k]+1): k in goodIndices];
	return coordsInC;
end function;
	
computeJCol:=function(Ofi,i,j,norms,goodIndices)
	col:=cicjInC(Ofi,i,j,norms,goodIndices);
	return jShifts(col,-norms[j]);
end function;

computeILine:=function(Ofi,i,norms,goodIndices)
	line:=&cat[computeJCol(Ofi,i,j,norms,goodIndices): j in goodIndices];
	return iShifts(line,-norms[i]);
end function;

/* The map to go back from the F-algebra to the K-algebra once we find idempotent elements*/
returnMap:=function(C,nA,Ofi,norms,goodIndices)
	cumulDims:=[0];
	sum:=0;
	for i in goodIndices do
		sum+:=-norms[i]+1;
		Append(~cumulDims,sum);
	end for;
	return map<C -> nA | c:->&+[R![c[k]: k in [cumulDims[i]+1..cumulDims[i+1]]]*Basis(Ofi)[j]: i->j in goodIndices]>;
end function;

interOrders:=function(A,Ofi,Oinf)
	nA,phi:=ChangeBasis(A,Basis(Oinf));
	Oinf:=Order(P,Basis(nA));
	Ofi:=rebaseOfi(Ofi,nA,phi);
//Now we have Ofi as a maximal R-order with a reduced basis, and coordinates in nA are written with respect to the basis of Oinf.
//The algebra C is generated by the x^j c_i, where (c_i) is our basis of Ofi and 0 <= j <= -norm(c_i).
	norms:=[norm(nA!c): c in Basis(Ofi)];
	goodIndices:=[i: i in [1..Dimension(A)] | norms[i] le 0];
	SC:=&cat[computeILine(Ofi,i,norms,goodIndices): i in goodIndices];
	C:=AssociativeAlgebra<F,#SC|SC: Check:=false>;
	f:=returnMap(C,nA,Ofi,norms,goodIndices);
	return C,f * Inverse(phi);
end function;

/*Given an associative K-algebra A which is isomorphic to a 2x2 matrix algebra over K, returns a rank 1 idempotent element of A*/
rankOneIdempotent:=function(A:Ofi:=0,Oinf:=0,verbose:=false)
	if Ofi cmpeq 0 then
		if verbose then
			print "Timing the computation of MaximalOrderFinite(A):";
			time Ofi:=MaximalOrderFinite(A);
		else
			Ofi:=MaximalOrderFinite(A);
		end if;
	else
		if verbose then
			print "Timing the computation of a maximal F_p[x]-order.";
			time Ofi:=MaximalOrder(Ofi);
		else
			Ofi:=MaximalOrder(Ofi);
		end if;
	end if;
	if Oinf cmpeq 0 then
		if verbose then
			print "Timing the computation of MaximalOrderInfinite(A):";
			time Oinf:=MaximalOrderInfinite(A);
		else
			Oinf:=MaximalOrderInfinite(A);
		end if;
	else 
		if verbose then
			print "Timing the computation of a maximal order at the infinite place.";
			time Oinf:=MaximalOrder(Oinf);
		else
			Oinf:=MaximalOrderInfinite(A);
		end if;
	end if;

	if verbose then
		print "A basis for our maximal F_q[T]-order is:";
		for b in Basis(Ofi) do
			print b;
			print "___";
		end for;

		print "***********";
		print "A basis of our maximal order at the infinite place is:";
		for b in Basis(Oinf) do
			print b;
			print "____";
		end for;
	end if;

	C,f:=interOrders(A,Ofi,Oinf);

	if verbose then
		print "We computed the intersection of our two maximal orders. We get a finite algebra with the following basis:";
		for b in Basis(C) do
			print b @ f;
			print "______";
		end for;
	end if;

	es:=[x @ f: x in orthSysOfPrimIdems(C)];
	return es[Index([Dimension(sub<A | [e*a*e : a in Basis(A)]>) : e in es],1)];
end function;

idemToIso:=function(A,e)
	_,d:=IsSquare(Dimension(A));
	V:=Module(A);
	W:=sub<V | [V!(e*X): X in Basis(A)]>;
	M,f:=AssociativeAlgebra(MatrixAlgebra(K,d));
	Ims:=[Matrix(K,[Coordinates(W,W!((A!w)*X)): w in Basis(W)]) @ f: X in Basis(A)];
	return hom<A -> M| Ims> * Inverse(f);
end function;

explicitIsomorphism:=function(A:Ofi:=0,Oinf:=0,verbose:=false)
	e:=rankOneIdempotent(A:Ofi:=Ofi,Oinf:=Oinf,verbose:=verbose);
	if verbose then
		print "We found a rank one idempotent element of the algebra. It has the following coordinates:";
		for x in Coordinates(A,e) do
			print x;
			print "---";
		end for;
		print "We may now use this idempotent element to compute an explicit isomorphism to the matrix algebra.";
	end if;
	iso:=idemToIso(A,e);

	if verbose then
		print "Applying the isomorphism we found to the basis elements of A, we find the following matrices:";
		for b in Basis(A) do
			print b @ iso;
			print "______________";
		end for;
	end if;

	return iso;
end function;


