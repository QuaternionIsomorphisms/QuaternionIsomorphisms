Z:=IntegerRing();
p:=5;
q:=p^1;
F:=GF(q);
K<x>:=RationalFunctionField(F);
R<X>:=IntegerRing(K);
P:=ValuationRing(K);
PK<T>:=PolynomialRing(K);

deg:=2;
D:=RandomIrreduciblePolynomial(F,deg);
Kext<t>:=ext<K | T^2-D>;
Rext:=IntegralClosure(R,Kext);
Pext:=IntegralClosure(P,Kext);
Gal:=Automorphisms(Kext);
sigma:=Gal[Index([s(x) eq x and &and[s(y) eq y: y in Basis(F)] and not IsIdentity(s) : s in Gal],true)];
printf "Randomly generated a quadratic extension of K. It was formed by taking the square-root of a polynomial of degree %o.\n",deg;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 							Utility							//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*Swaps in place elements of index i and j in list L*/

swap := procedure(i,j,~L)
    a:=L[i];
    L[i]:=L[j];
    L[j]:=a;
end procedure;

//Evaluate a permutation written as a product of transpositions at integer i
evalPerm:=function(perm,i)
	for t in perm do
		if i eq t[1] then
			i:=t[2];
		elif i eq t[2] then
			i:=t[1];
		end if;
	end for;
	return i;
end function;

evalInversePerm:=function(perm,i)
	return evalPerm(Reverse(perm),i);
end function;
	
shift:=function(L)
	assert L ne [];
	return [R!0] cat L[1..(#L-1)];
end function;

/* Returns a sequence containing L and then the N sequences obtained by consecutive shifts of L*/
jShifts:=function(L,N)
	bigL:=[L];
	acc:=L;
	for j:= 1 to N do
		acc:=shift(acc);
		Append(~bigL,acc);
	end for;
	return bigL;
end function;

/*L is a sequence of sequences. Return a sequence of sequences of sequences containing first L and then sequences of shifted elements of L, first once, then twice up to n times*/
iShifts:=function(L,N)
	bigL:=[L];
	acc1:=L;
	acc2:=[];
	for i:=1 to N do
		for M in acc1 do
			Append(~acc2,shift(M));
		end for;
		Append(~bigL,acc2);
		acc1:=acc2;
		acc2:=[];
	end for;
	return bigL;
end function;

/*Assuming f is known to be a module homomorphism, test if it is in fact an algebra homomorphism*/
isAlgebraHom:=function(f)
	A:=Domain(f);
	B:=Codomain(f);
	ones:=One(B) eq (One(A) @ f);
	return ones and &and[((x*y) @ f) eq (x @ f)*(y @ f): x,y in Basis(A)];
end function;

/*Replaces the i-th column of M with C*/
changeRow:=procedure(~M,R,i)
	assert (NumberOfRows(R) eq 1);
	n:=NumberOfColumns(R);
	for j := 1 to n do
		M[i,j]:=R[1,j];
	end for;
end procedure;

/*Returns the difference of the degrees of the numerator and of the denominator
of r*/
sgnDegree := function(r)
    return (Degree(Numerator(r))-Degree(Denominator(r)));
end function;


/*Returns the norm of a line matrix*/
norm := function(v)
    return Max([sgnDegree(x) : x in ElementToSequence(v) | x ne 0]);
end function;

lcmList:=function(L)
	r:=1;
	for P in L do
		r:=Lcm(r,P);
	end for;
	return r;
end function;

denominatorsList:=function(L)
	return [Denominator(r): r in L];
end function;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//					Generating random examples						//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*Random polynomial with degree lower or equal to n over our Galois field*/
randPolyFF := function(n: nonZero:=false,precise:=false)
	d:=n;
	repeat
		if not precise then
			d := Random(n);
		end if;
		repeat
			dom:=Random(F);
		until dom ne 0;
		p := R!([Random(F) :_ in [0..d-1]] cat [dom]);
	until not (nonZero and (p eq R!0));
	return p;
end function;

/*Random rational function with numerator and denominator degree lower or equal to n over our Galois field*/
randRatFunFF := function(d: nonZero:=false)
	repeat
		x:= K!randPolyFF(d)/K!randPolyFF(d: nonZero:=true);
	until (not nonZero) or x ne 0;
	return x;
end function;

randKext := function(d: nonZero:=false)
	repeat
		x:=Kext![randRatFunFF(d): _ in [1..2]];
	until (not nonZero) or x ne 0;
	return x;
end function;

randomFld:=function(L: nonZero:=false, d:=2)
	if L eq K then
		return randRatFunFF(d);
	elif L eq Kext then
		return Kext![randPolyFF(d:nonZero:=nonZero)/randPolyFF(d:nonZero:=true): _ in [1..2]];
	else
		error "not implemented";
	end if;
end function;

scrambleBasis:=function(A:d:=1,verbose:=false,M:=0)
	n:=Dimension(A);
	L:=BaseField(A);
	if M cmpeq 0 then
		repeat
			M:=Matrix(L,[[Random(2) eq 0 select randomFld(L:d:=d) else 0: _ in [1..n]]: _ in [1..n]]);
		until Determinant(M) ne 0;
		if verbose then
			printf "Scrambling the basis of %o. We're using the following matrix: \n%o\n",A,M;
		end if;
	end if;
	B,f:=ChangeBasis(A,[A!ElementToSequence(M[i]): i in [1..n]]);
	return B,f,M;
end function;

/*Randomly generates an n^2 dimensional algebra over K isomorphic to the order n square matrix algebra.
The parameter d is the bound for the degree of the random entries of the matrix used for construction.*/
randIsoMat:=function(L,n:d:=2,verbose:=false)
	M:=MatrixAlgebra(L,n);
	A1,g:=AssociativeAlgebra(M);
	A,f:=scrambleBasis(A1:d:=d,verbose:=verbose);
	return A,g*f;
end function;

randIsoQuat:=function(L:d:=2,nonSplit:=false,scramble:=false)
	repeat
		a:=randomFld(L: d:=d, nonZero:=true);
		b:=randomFld(L: d:=d, nonZero:=true);
		B:=QuaternionAlgebra<L| a,b>;
	until not (nonSplit and Discriminant(B) eq 1);
	Ba:=AssociativeAlgebra(B);
	if scramble then
		Ba:=scrambleBasis(Ba:d:=d);
	end if;
	if L eq K then
		return Ba,Discriminant(B);
	end if;
	return Ba;
end function;	

randIsoQuatGentle:=function(:d:=1,degN:=1,verbose:=false)
	count:=0;
	repeat
		N1:=RandomPrimePolynomial(R,degN);
		count+:=1;
		if count gt q^degN then
			degN+:=1;
		end if;
	until JacobiSymbol(D,N1) eq 1;
	repeat
		N2:=RandomPrimePolynomial(R,degN);
		count+:=1;
		if count gt q^degN then
			degN+:=2;
		end if;
	until JacobiSymbol(D,N2) eq 1 and N2 ne N1;
	N:=N1*N2;
	A:=QuaternionAlgebra(N);
	a,b:=StandardForm(A);
	A:=AssociativeAlgebra(A);
	B,_,M:=scrambleBasis(A:d:=d);
	A:=ChangeRing(A,Kext);
	B:=ChangeRing(B,Kext);
	if verbose then
		printf "Generated a quaternion algebra over K with reduced discriminant %o, and lifted it to Kext.\n",N;
		printf "That is to say, our algebra is (%o,%o) over Kext.\n",a,b;
		print "I used the following matrix to scramble the basis of B2:";
		print M;
	end if;
	return A,B,N;
end function;
	


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//					Lattice reduction functions						//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*Reduces a lattice basis in F_q[X]^n in place, using Lenstra's algorithm from [1]*/
reduceLatBase := procedure(~B)
    k:=0;
	n:=NumberOfRows(B);
	assert(n eq NumberOfColumns(B));
    norms:=[norm(RowSubmatrix(B,i,1)) : i in [1..n]];
    perms:=[];
    while k lt n do
        _,i:=Min(norms[k+1..n]);
        B:=SwapRows(B,k+1,k+i);
		swap(k+1,k+i,~norms);
		if k gt 0 then
			LHS:=Matrix(F,k,k,[[Coefficient(B[i,j],norms[i]) : j in [1..k]] : i in [1..k]]);
			RHS:=Matrix(F,1,k,[Coefficient(B[k+1,j],norms[k+1]): j in [1..k]]);
			r:=Solution(LHS,RHS);
			b:=RowSubmatrix(B,k+1,1) - &+[r[1][i]*(X^(norms[k+1]-norms[i]))*RowSubmatrix(B,i,1) : i in [1..k]];
			changeRow(~B,b,k+1);
			N:=norm(b);
		end if;
		if k eq 0 or N eq norms[k+1] then
			_,j0:=Max([sgnDegree(B[k+1,j]): j in [k+1..n]]);
			B:=SwapColumns(B,k+1,k+j0);
			Append(~perms,<k+1,k+j0>);
			k+:=1;
		else
			norms[k+1]:=N;
			i0:=Index([norms[i] gt norms[k+1] : i in [1..k+1]],true)-1;
			if i0 ne -1 then
				k:=i0;
			end if;
		end if;
    end while;
    Reverse(~perms);
    for T in perms do
        B:=SwapColumns(B,T[1],T[2]);
    end for;
end procedure;

/*Reduces a lattice basis in F_q(X)^n in place, using Proposition 8 in [2]*/
reduceRatLatBase := procedure(~B)
	n:=NumberOfColumns(B);
	assert(n eq NumberOfColumns(B));
    g:=R!1;
    for i := 1 to n do
        for j := 1 to n do
            g:= Lcm(g,Denominator(B[i,j]));
        end for;
    end for;
    gB:=ChangeRing(g*B,R);
    reduceLatBase(~gB);
    B:=(1/g)*gB;
end procedure;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//						Finite algebras							//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//This is an implementation of the algorithm given in part 3 of [4].
//Returns a subalgebra of C isomorphic to C/J, where J is the Jacobson radical of C.
WedderburnMalcev:=function(C:Jac:=0)
	if Jac cmpeq 0 then
		Jac:=JacobsonRadical(C);
	end if;
	BJac:=[C!x : x in Basis(Jac)];
	n:=Dimension(C);
	k:=n-#BJac;
	if k eq n then
		return C;
	end if;
	W,f:=VectorSpace(C);
	g:=Inverse(f);
	R:=sub<W | [f(x) : x in BJac]>;
	V:=Complement(W,R);
	NewBase:=[g(x):x in Basis(V)] cat BJac;
	A:=ChangeBasis(C,NewBase);
	W,f:=VectorSpace(A);
	g:=Inverse(f);
	BR:=Basis(A)[k+1..n];
	BV:=Basis(A)[1..k];
	dV:=k;
	R:=sub<W | [f(x) : x in BR]>;
	V:=Complement(W,R);
	B:=Basis(A)[1..k];
	repeat
		Rtmp:=sub<R | [f(x*y) : x in Basis(A)[k+1..n], y in BR] cat [f(y*x) : x in Basis(A)[k+1..n], y in BR]>;
		V:=Complement(R,Rtmp);
		R:=Rtmp;
		BV:=[g(x):x in Basis(V)];
		BR:=[g(x):x in Basis(R)];
		dV:=Dimension(V);
		LHS:=Matrix([&cat[Coordinates(W,ReduceVector(R,f(B[i]*d[j] + d[i]*B[j] - &+[BasisProduct(A,i,j)[s]*d[s] : s in [1..k]]))) : i,j in [1..k]] :
		d in [[A!0 : _ in [1..(i-1)]] cat [d] cat [A!0 : _ in [i+1..k]]: d in BV, i in [1..k]]]);
		RHS:= Matrix([&cat[Coordinates(W,ReduceVector(R,f(&+[BasisProduct(A,i,j)[s]*B[s] : s in [1..k]] - B[i]*B[j]))) : i,j in [1..k]]]);
		Sol:=Solution(LHS,RHS);
		for i := 1 to k do
			B[i]+:=&+[Sol[1][(i-1)*dV+j]*BV[j] : j in [1..dV]];
		end for;
	until Dimension(R) eq 0;
	return sub<C | [&+[x[i]*e : i->e in NewBase] : x in B]>;
end function;


//A is a simple algebra over F
//Returns an isomorphism from M_n(k) to A, with k the center of A.*/
explIso:=function(A)
	rcA,frcA:=AlgebraOverCenter(A);
	k:=BaseField(rcA);
	_,n:=IsSquare(Dimension(rcA));
	I:=MinimalLeftIdeals(rcA:Limit:=1)[1];
	LHS:=Matrix([&cat[Coordinates(I,x*y): y in Basis(I)]: x in Basis(rcA)]);
	phi:=hom<MatrixAlgebra(k,n) -> rcA | M :-> rcA!ElementToSequence(Solution(LHS,Matrix(1,n^2,ElementToSequence(M))))>;
	return phi * frcA;
end function;

//A is a simple algebra over F.
//Returns a complete orthogonal decomposition in primitive idempotents of A
decomposeSimple:=function(A)
	if IsCommutative(A) then
		return [A!1];
	end if;
	f:=explIso(A);	
	M:=Domain(f);
	n:=Degree(M);
	return [f(x) : x in Basis(M)[1..n^2 by n+1]];
end function;

//A is a finite algebra
//Returns a complete orthogonoal system of primitive idempotents of A
orthSysOfPrimIdems:=function(A)
	W:=WedderburnMalcev(A);
	Ies := DirectSumDecomposition(W);
	return &cat[[A!x : x in decomposeSimple(I)] : I in Ies];
end function;
	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//				Computing isomorphism to a matrix algebra over K [2]				//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Ofi is a maximal Fq[x]-order in A, Oinf is a maximal R-order in A.
This function returns a Fq-basis of their intersection, and the structure constants for this intersection as a Fq-algebra
This subroutine implements an algorithm given by lemma 25 in [2]*/

/*Returns a list of length d containing the d lowest degree (possibly zero) coefficients of P*/
coefficientsUpTo:=function(P,d)
	if P eq 0 then
		return [0: _ in [1..d]];
	end if;
	return (Coefficients(P) cat [0: _ in [0..d-Degree(P)]])[1..d];
end function;

rebaseOfi:=function(Ofi,nA,phi)
	M:=Matrix([Coordinates(nA,phi(e)): e in Basis(Ofi)]);
	reduceRatLatBase(~M);
	return Order(R,[nA!ElementToSequence(M[i]): i in [1..Dimension(nA)]]);
end function;
	
/*given ci and cj elements of the reduced basis of Ofi, expresses their product in the F-basis of Ofi \cap Oinf*/
cicjInC:=function(Ofi,i,j,norms,goodIndices)
	p:=Basis(Ofi)[i]*Basis(Ofi)[j];
	coords:=Coordinates(Ofi,p);
	coordsInC:=&cat[coefficientsUpTo(R!coords[k],-norms[k]+1): k in goodIndices];
	return coordsInC;
end function;
	
computeJCol:=function(Ofi,i,j,norms,goodIndices)
	col:=cicjInC(Ofi,i,j,norms,goodIndices);
	return jShifts(col,-norms[j]);
end function;

computeILine:=function(Ofi,i,norms,goodIndices)
	line:=&cat[computeJCol(Ofi,i,j,norms,goodIndices): j in goodIndices];
	return iShifts(line,-norms[i]);
end function;

/* The map to go back from the F-algebra to the K-algebra once we find idempotent elements*/
returnMap:=function(C,nA,Ofi,norms,goodIndices)
	cumulDims:=[0];
	sum:=0;
	for i in goodIndices do
		sum+:=-norms[i]+1;
		Append(~cumulDims,sum);
	end for;
	return map<C -> nA | c:->&+[R![c[k]: k in [cumulDims[i]+1..cumulDims[i+1]]]*Basis(Ofi)[j]: i->j in goodIndices]>;
end function;

interOrders:=function(A,Ofi,Oinf)
	nA,phi:=ChangeBasis(A,Basis(Oinf));
	Oinf:=Order(P,Basis(nA));
	Ofi:=rebaseOfi(Ofi,nA,phi);
//Now we have Ofi as a maximal R-order with a reduced basis, and coordinates in nA are written with respect to the basis of Oinf.
//The algebra C is generated by the x^j c_i, where (c_i) is our basis of Ofi and 0 <= j <= -norm(c_i).
	norms:=[norm(nA!c): c in Basis(Ofi)];
	goodIndices:=[i: i in [1..Dimension(A)] | norms[i] le 0];
	SC:=&cat[computeILine(Ofi,i,norms,goodIndices): i in goodIndices];
	C:=AssociativeAlgebra<F,#SC|SC: Check:=false>;
	f:=returnMap(C,nA,Ofi,norms,goodIndices);
	return C,f * Inverse(phi);
end function;

/*Given an associative K-algebra A which is isomorphic to a 2x2 matrix algebra over K, returns a rank 1 idempotent element of A*/
rankOneIdempotent:=function(A:Ofi:=0,Oinf:=0)
	if Ofi cmpeq 0 then
		print "Timing the computation of MaximalOrderFinite(A).";
		time Ofi:=MaximalOrderFinite(A);
	else
		Ofi:=MaximalOrder(Ofi);
	end if;
	if Oinf cmpeq 0 then
		print "Timing the computation of MaximalOrderInfinite(A).";
		time Oinf:=MaximalOrderInfinite(A);
	else 
		Oinf:=MaximalOrder(Oinf);
	end if;
	C,f:=interOrders(A,Ofi,Oinf);
	es:=[x @ f: x in orthSysOfPrimIdems(C)];
	return es[Index([Dimension(sub<A | [e*a*e : a in Basis(A)]>) : e in es],1)];
end function;

idemToIso:=function(A,e)
	_,d:=IsSquare(Dimension(A));
	V:=Module(A);
	W:=sub<V | [V!(e*X): X in Basis(A)]>;
	M,f:=AssociativeAlgebra(MatrixAlgebra(K,d));
	Ims:=[Matrix(K,[Coordinates(W,W!((A!w)*X)): w in Basis(W)]) @ f: X in Basis(A)];
	return hom<A -> M| Ims> * Inverse(f);
end function;

explicitIsomorphism:=function(A:Ofi:=0,Oinf:=0)
	e:=rankOneIdempotent(A:Ofi:=Ofi,Oinf:=Oinf);
	return idemToIso(A,e);
end function;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//				Computing an involution of the second kind					//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*Input: An associative algebra isomorphic to a quaternion algebra over some field
Output: The standard involution of this algebra.*/
stdInv:=function(B)
	return hom<B -> B | [Trace(x)/2 - x: x in Basis(B)]>;
end function;

tensorProductOrders:=function(O1,O2,phiA,phiB,dA,dB,k)
	if k eq K then
		BA:=Basis(O1);
		BB:=Basis(O2);
		BO:=[phiA(a)*phiB(b): b in BB, a in BA];
	 	OC:=Order(BaseRing(O1),BO);

	elif k eq Kext then
		PBA:=PseudoBasis(O1);
		PBB:=PseudoBasis(O2);
		S:=[phiA(PBA[i][2])*phiB(PBB[j][2]): j in [1..dB], i in [1..dA]];
		I:=[PBA[i][1]*PBB[j][1]: j in [1..dB], i in [1..dA]];
		OC:=Order(S,I);

	else
		error "not implemented";
	end if;

	return OC;
end function;

/*Input: A and B are algebras over a field k.
Output: The tensor product of A and B over k as a structure constant algebras, a map from A to it and a map from B to it.
Parameters: If A and B are quaternion algebras (with standard basis), also returns an involution of the first kind on A(x)B coming from that of A and that of B.*/
tensorProduct:=function(A,B:quats:=false,Ofis:=0,Oinfs:=0)
	k:=BaseField(A);
	assert k eq BaseField(B);
	SC:=[[[a*b : b in ElementToSequence(BasisProduct(B,iB,jB)), a in ElementToSequence(BasisProduct(A,iA,jA))]:
		jB in [1..Dimension(B)], jA in [1..Dimension(A)]]:
		iB in [1..Dimension(B)], iA in [1..Dimension(A)]];
	C:=AssociativeAlgebra<k, Dimension(A)*Dimension(B) | SC: Check:=false>;
	oneA:=Coordinates(A,One(A));
	oneB:=Coordinates(B,One(B));
	phiA:=hom<A -> C | [&+[c*Basis(C)[(i-1)*Dimension(B)+j]: j->c in oneB]: i in [1..Dimension(A)]]>;
	phiB:=hom<B -> C | [&+[c*Basis(C)[j+(i-1)*Dimension(B)]: i->c in oneA]: j in [1..Dimension(B)]]>;
	sC:=0;
	if quats then
		invA:=stdInv(A);
		invB:=stdInv(B);
		sC:=hom<C -> C | [phiA(invA(a))*phiB(invB(b)) : b in Basis(B), a in Basis(A)]>;
	end if;

	Ofi:=0;
	Oinf:=0;

	if Ofis cmpne 0 then
		Ofis:=[MaximalOrder(O): O in Ofis];
		Ofi:=tensorProductOrders(Ofis[1],Ofis[2],phiA,phiB,Dimension(A),Dimension(B),k);
	end if;
	if Oinfs cmpne 0 then
		Oinfs:=[MaximalOrder(O): O in Oinfs];
		Oinf:=tensorProductOrders(Oinfs[1],Oinfs[2],phiA,phiB,Dimension(A),Dimension(B),k);
	end if;

	return C,phiA,phiB,sC,Ofi,Oinf;
end function;

conjugAlg:=function(A)
	As:=AssociativeAlgebra<Kext, Dimension(A) | [[[sigma(a): a in Coordinates(A,BasisProduct(A,i,j))]: j in [1..Dimension(A)]]:i in [1..Dimension(A)]]: Check:=false>;
	AToAs:=map<A -> As | x:->As![sigma(a): a in Coordinates(A,x)], y:->A![sigma(as): as in Coordinates(As,y)]>;
	return As,AToAs;
end function;

conjugIdeal:=function(I,Ri)
	return ideal<Ri | [sigma(e): e in Generators(I)]>;
end function;

conjugOrder:=function(O,AToAs)
	Ri:=BaseRing(O);
	PB:=PseudoBasis(O);
	sO:=Order([AToAs(PB[i][2]): i in [1..Dimension(O)]],[conjugIdeal(PB[i][1],Ri): i in [1..Dimension(O)]]);
	return sO;
end function;

restrictScalarsVS:=function(A)
	V:=VectorSpace(K,2*Dimension(A));
	return V,map<A -> V | x:->V!(&cat[Eltseq(a): a in Eltseq(x)]), y:->A![y[i]+t*y[i+1]: i in [1..Dimension(V) by 2]]>;
end function;

fixedPoints:=function(s,B,Ri)
	iP:=(Matrix([Eltseq(v): v in B]))^(-1);
	LHS:=Matrix(Ri,[Eltseq(Matrix([Eltseq(s(x) - x)])*iP) : x in B]);
	return [&+[v[i]*b: i->b in B]: v in Basis(Nullspace(LHS))];
end function;

descendOrderPB:=function(O)
	PB:=PseudoBasis(O);
	Ri:=BaseRing(O);
	B:=&cat[[t*PB[i][2]: t in Basis(PB[i][1])]: i in [1..Dimension(O)]];
	return B;
end function;

//A is an algebra over Kext. f is a map from V to A, where V is A as a vector space over K
//twist is a semi-linear map, defined over V, and this function outputs the K-subalgebra of A containing the elements fixed by A.
descendAlgebra:=function(A,f,Ofi,Oinf,twist:computeOrders:=true)
	if computeOrders then
		BROfi:=descendOrderPB(Ofi);
		BPOinf:=descendOrderPB(Oinf);

		BC:=fixedPoints(twist,[a @ f: a in BPOinf],P);
		BOCFi:=fixedPoints(twist,[a @ f: a in BROfi],R);
	else
		BC:=fixedPoints(twist,Basis(Codomain(f)),K);
	end if;

	C,g:=ChangeBasis(A,[v @@ f: v in BC]);
	C,h:=ChangeRing(C,K);
	
	if computeOrders then
		OCInf:=Order(P,Basis(C));
		OCFi:=Order(R,[(o @@ f) @ (g * h): o in BOCFi]);
	else
		OCInf:=0;
		OCFi:=0;
	end if;

	return C,Inverse(g*h),OCFi,OCInf;
end function;

/*Input: A central simple algebra A defined over L.
Output: The corestriction of A as an associative algebra over K, the tensor product AxAs, a map from A to AxAs and a map from Cor(A) to A.*/
corestriction:=function(A:Ofi:=0,Oinf:=0,computeOrders:=true)
	if computeOrders then
		if Ofi cmpeq 0 then
			Ofi:=MaximalOrderFinite(A);
		else
			Ofi:=MaximalOrder(Ofi);
		end if;
		if Oinf cmpeq 0 then
			Oinf:=MaximalOrderInfinite(A);
		else
			Ofi:=MaximalOrder(Ofi);
		end if;
	end if;
	As,AToAs:=conjugAlg(A);
	
	if computeOrders then
		Ofis:=conjugOrder(Ofi,AToAs);
		Oinfs:=conjugOrder(Oinf,AToAs);
	end if;

	AxAs,phiA,phiAs,sC,OfixOfis,OinfxOinfs:=tensorProduct(A,As:Ofis:=computeOrders select [Ofi,Ofis] else 0,Oinfs:=computeOrders select [Oinf,Oinfs] else 0);

	V,f:=restrictScalarsVS(AxAs);
	switch:=hom<V -> V | &cat[[(sigma(k)*v) @ f: k in Basis(Kext)] where v is (((as @@ AToAs) @ phiA)*((a @ AToAs) @ phiAs)): as in Basis(As), a in Basis(A)]>;

	Cor,phi,OCorFi,OCorInf:=descendAlgebra(AxAs,f,OfixOfis,OinfxOinfs,switch: computeOrders:=computeOrders);
	return Cor,AxAs,AToAs,phiA,phiAs,phi,OCorFi,OCorInf;
end function;

proj:=function(L,k)
	A:=Universe(L);
	M:=(Matrix([ElementToSequence(x): x in L]))^(-1);
	Images:=[];
	for x in Basis(A) do
		Append(~Images,&+[(Matrix([Coordinates(A,x)])*M)[1,i]*L[i]: i in [k+1..#L]]);
	end for;
	return hom<A -> A | Images>;
end function;

/*Input: an ideal I of AxAs that is in direct sum with A, coming from an ideal of the Corestriction, as well as the maps phiA,phiAs and AToAs coming from an ideal of the Corestriction.
Output:	an involution of the second kind on A*/
invSecFromI:=function(I,AxAs,phiA,phiAs,AToAs)
	A:=Domain(phiA);
	B:=Basis(I) cat Basis(Image(phiA));
	f:=proj(B,Dimension(I));
	return AToAs * phiAs * f * Inverse(phiA);
end function;

/*Input: An algebra A over Kext
Output: A zero divisor in A or an involution of the second kind on A*/
invSec:=function(A:Ofi:=0,Oinf:=0)
	Cor,AxAs,AToAs,phiA,phiAs,phiCor,Ofi,Oinf:=corestriction(A:Ofi:=Ofi,Oinf:=Oinf);
	e:=rankOneIdempotent(Cor:Ofi:=Ofi,Oinf:=Oinf);
	print "We have succesfully computed a rank one idempotent in the corestriction of A!";
	I:=rideal<AxAs | phiCor(1-e)>;
	Inter:= I meet sub<AxAs | [phiA(x) : x in Basis(A)]>;
	if Dimension(Inter) gt 0 then
		return (Basis(Inter)[1]) @@ phiA,0;
	end if;
	return A!0,invSecFromI(I,AxAs,phiA,phiAs,AToAs);
end function;
	
		
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//					Solving quadratic forms [5]						//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//The built in Facpol function returns an error when its input is [].
goodFacpol:=function(Facto)
	if Facto eq [] then
		return R!1;
	end if;
	return Facpol(Facto);
end function;

//First, the functions for minimizing a quaternary form.

//Functions for computing the squarefree parts of the coefficients
isSquare:=function(Fact)
	return &and[IsEven(L[2]): L in Fact],[<F[1],F[2] div 2>: F in Fact]; 
end function;

squareFree:=function(Fact)
	C:=CartesianProduct(R,Z);
	SquareFreePart:=[C|];
	SquareFactor:=[C|];
	for F in Fact do
		r:=F[2] mod 2;
		if r eq 1 then
			Append(~SquareFreePart,<F[1],1>);
		end if;
		s:=F[2]-r;
		if s ne 0 then
			Append(~SquareFactor,<F[1],s div 2>);
		end if;
	end for;
	return SquareFreePart,SquareFactor;
end function;	

squareFreeCoeffs:=function(L)
	NewCoeffs:=[];
	Diag:=[K|];
	for F in L do
		sqrfree,sqrfact:=squareFree(F);
		Append(~NewCoeffs,sqrfree);
		Append(~Diag,goodFacpol(sqrfact));
	end for;
	return NewCoeffs,DiagonalMatrix(Diag);
end function;

//Functions for bringing the factorizations of our squarefree coefficients in one list. It's simpler to manipulate this way.
addFactor:=function(L,f,i)
	j:=Index([c[1] eq f: c in L],true);
	if j eq 0 then
		return L cat [<f,[i]>];
	else
		return L[1..j-1] cat [<f,L[j][2] cat [i]>] cat L[j+1..#L];
	end if;
end function;

addFactorisation:=function(L,facto,i)
	for f in facto do
		L:=addFactor(L,f[1],i);
	end for;
	return L;
end function;

//The behavior is undefined if the coeffs are not all square free.
jointFactoTransfo:=function(coeffs)
	L:=[];
	for i->facto in coeffs do
		L:=addFactorisation(L,facto,i);
	end for;
	return L;
end function;

addToCoeffs:=procedure(~coeffs,f,L)
	for i in L do
		Append(~coeffs[i],<f,1>);
	end for;
end procedure;

splitFactoTransfo:=function(L,n)
	coeffs:=[[]: _ in [1..n]];
	for c in L do
		addToCoeffs(~coeffs,c[1],c[2]);
	end for;
	return coeffs;
end function;
	

//Now we may clear quartic and cubic factors from the discriminant.
removeSubsequence:=function(L,I)
	if I eq [] then
		return L;
	end if;
	return L[1..I[1]-1] cat &cat[L[I[i]+1..I[i+1]-1]: i in [1..#I-1]] cat L[I[#I]+1..#L];
end function;

complement:=function(L,n)
	return [i: i in [1..n] | not i in L];
end function;

clearMajorityFactor:=function(c,n)
	I:=complement(c[2],n);
	c:=<c[1],I>;
	Diag:=[K!1: _ in [1..n]];
	for i in c[2] do
		Diag[i]:=1/c[1];
	end for;
	return c,DiagonalMatrix(Diag);
end function;

dealWithSquareFactor:=function(c,as)
	I:=complement(c[2],4);
	s:=-as[I[1]]*as[I[2]];
	j:=JacobiSymbol(s,c[1]);
	assert j ne 0;
	if j eq 1 then
		return c,as,DiagonalMatrix(K,[1: _ in [1..4]]);
	end if;
	assert JacobiSymbol(-as[c[2][1]]*as[c[2][2]] div c[1]^2,c[1]) eq 1;
	D:=[K!1: _ in [1..4]];
	for i in I do
		as[i]*:=c[1];
	end for;
	for i in c[2] do
		D[i]*:=c[1];
		as[i]div:=c[1];
	end for;
	M:=DiagonalMatrix(D);
	return <c[1],I>,as,M;
end function;

testLeadingCoeffs:=function(as)
	if #[a : a in as| IsSquare(LeadingCoefficient(a))] ge 2 then
		return as;
	end if;
	r:=F!1;
	repeat
		r+:=1;
	until not IsSquare(r);
	return [r*a: a in as];
end function;

sqrfAndCubeFree:=function(as)
	n:=#as;
	L:=[];
	LeadingCoeffs:=[];
	for a in as do
		facto,coeff:=Factorisation(R!a);
		Append(~L,facto);
		Append(~LeadingCoeffs,coeff);
	end for;
	L,M:=squareFreeCoeffs(L);
	L:=jointFactoTransfo(L);
	for i->c in L do
		if #c[2] ge 3 then
			L[i],T:=clearMajorityFactor(c,n);
			M*:=T;
		end if;
	end for;
	as:=splitFactoTransfo(L,n);
	return [LeadingCoeffs[i]*goodFacpol(a): i->a in as],M,L;
end function;
	
minimiseQuaternary:=function(as)
	as,M,L:=sqrfAndCubeFree(as);
	for i->c in L do
		if #c[2] eq 2 then
			L[i],as,T:=dealWithSquareFactor(c,as);
			M*:=T;
		end if;
	end for;	
	as:=testLeadingCoeffs(as);
	return as,M,L;
end function;

minimiseQuintenary:=function(as)
	as,T,L:=sqrfAndCubeFree(as);
	return as,T,L;
end function;

evensAndOdds:=function(L)
	Evens:=[];
	Odds:=[];
	for i->p in L do
		if IsEven(Degree(p)) then
			Append(~Evens,i);
		else
			Append(~Odds,i);
		end if;
	end for;
	return Evens,Odds;
end function;

isIsotropicAtInfinity:=function(as,evenDegrees,oddDegrees)
	if #evenDegrees ne 2 then
		return true;
	end if;
	l1:=-LeadingCoefficient(as[evenDegrees[1]])*LeadingCoefficient(as[evenDegrees[2]]);	
	l2:=-LeadingCoefficient(as[oddDegrees[1]])*LeadingCoefficient(as[oddDegrees[2]]);	
	return IsSquare(l1) or IsSquare(l2);
end function;

solveConstantForm:=function(as)
	count:=0;
	repeat
		xs:=[Random(F): _ in [1..3]];
		s:=-(&+[as[i]*x^2: i->x in xs])/as[4];
		IsSol,Sol:=IsSquare(s);
		count+:=1;
	until IsSol or count eq 20;
	if not IsSol then
		print "Error in solveConstantForm";
		return [0,0,0,0];
	end if;
	return xs cat [eval"Sol"];
end function;
	

solveBinaryForm:=function(as)
	SolExists,sqrt:=IsSquare(-as[1]/as[2]);
	if SolExists then
		return eval"SolExists,[K | Numerator(sqrt),Denominator(sqrt)]";
	else
		return false,[];
	end if;
end function;	

checkBinaries:=function(as)
	//printf "About to check them binaries. The as are %o.\n",as;
	for i:=1 to 4 do
		for j:=i+1 to 4 do
			SolExists,Sol:=solveBinaryForm([as[i],as[j]]);
			if SolExists then
				//printf "I'm in check binaries and I just found a solution.";
				return true,Sol,i,j;
			end if;
		end for;
	end for;
	return false,[],0,0;
end function;

irreducibleFactors:=function(a,b)
	a1s:=[c[1]: c in a];
	b1s:=[c[1]: c in b];
	return [R| f: f in a1s | f in b1s],[[R| f: f in a1s | not f in b1s],[R| f: f in b1s | not f in a1s]];
end function;

fsAndgs:=function(fbs)
	fs,conds1:=irreducibleFactors(fbs[1],fbs[2]);
	gs,conds2:=irreducibleFactors(fbs[3],fbs[4]);
	return &*fs * &*gs,conds1 cat conds2;
end function;

computeFs:=function(bs,fbs)
	fs,conds1:=irreducibleFactors(fbs[1],fbs[2]);
	factors:=[[c[1]: c in f]: f in fbs[3..5]];
	conds2:=[[R|]: _ in [1..3]];
	prod:=&*bs[3..5];
	for g in [c[1]: c in Factorisation(prod)] do
		Mg:=[i: i->b in bs[3..5] | not IsDivisibleBy(b,g)];
		if #Mg eq 1 then
			Append(~conds2[Mg[1]],g);
		end if;
	end for;
	return &*fs,conds1,conds2;
end function;

addTranspo:=procedure(~Perms,~bs,~fbs,i,j)
	Append(~Perms,<i,j>);
	swap(i,j,~bs);
	swap(i,j,~fbs);
end procedure;

threeToTwo:=function(i,j)
	Perm:=[<1,i>];
	if j eq 1 then
		Append(~Perm,<2,i>);
	else
		Append(~Perm,<2,j>);
	end if;
	return Perm;
end function;	

threeToOne:=function(bs,i)
	j:=Index([IsSquare(LeadingCoefficient(b)): j->b in bs[1..4] | j ne i],true);
	Perm:=[<1,i>,<j eq 1 select i else j,2>];
	return Perm;
end function;

twoToTwo:=function(bs,oddDegrees)	
	Perm:=[<1,oddDegrees[1]>,<oddDegrees[oddDegrees[2] eq 1 select 1 else 2],3>];
	cs:=[IsSquare((-1)^((i-1) div 2) * LeadingCoefficient(bs[evalInversePerm(Perm,i)])): i in [1..4]];
	if cs[2] and cs[4] then
		eps:=0;
	elif cs[1] and cs[3] then
		eps:=1;
	elif not cs[1] then
		assert not cs[3] and q mod 4 eq 3;
		eps:=1;
		Append(~Perm,<1,3>);
	else
		assert not cs[4] and q mod 4 eq 3;
		eps:=0;
		Append(~Perm,<2,4>);
	end if;
	return Perm,eps;
end function;

permHousekeeping:=procedure(Perm,~bs,~factorsOfBs)
	for t in Perm do
		swap(t[1],t[2],~bs);
	end for;
	for i->fact in factorsOfBs do
		factorsOfBs[i][2]:=[evalPerm(Perm,i): i in fact[2]];
	end for;
end procedure;	

polyWithSymb:=function(g,sym)
	d:=Degree(g);
	assert sym eq -1 or sym eq 1;
	repeat
		f:=randPolyFF(d-1);
	until JacobiSymbol(f,g) eq sym;
	return f;
end function;

goodCRT:=function(L1,L2)
	if L1 eq [] and L2 eq [] then
		return R!1;
	else
		return CRT(L1,L2);
	end if;
end function;

addCondition:=procedure(~rems,~mods,modu,polySymb)
	Append(~rems,polyWithSymb(modu,JacobiSymbol(polySymb,modu)));
	Append(~mods,modu);
end procedure;	

addDoubleCondition:=procedure(~rems,~mods,modu,factor,polySymb1,polySymb2)
	Jaco2:=JacobiSymbol(factor*polySymb2,modu);
	repeat
		P:=polyWithSymb(modu,JacobiSymbol(factor*polySymb1,modu));
	until JacobiSymbol(P,modu) eq Jaco2;
		Append(~rems,P);
		Append(~mods,modu);
end procedure;

jFromI:=function(i)
	assert i in IntegerRing();
	assert i ge 1;
	assert i le 4;
	
	if i le 2 then
		return 3-i,1;
	else
		return 7-i,-1;
	end if;
end function;

factorAndModCond:=function(bs,factorsOfBs)
	factor:=R!1;
	rems:=[R|];
	mods:=[R|];
	
	for f in factorsOfBs do
		modu:=f[1];
		multiples:=f[2];
		assert #multiples le 2;

		if #multiples eq 2 and (multiples[1]-1) div 2 eq (multiples[2] - 1) div 2 then
			factor*:=modu;
		end if;
	end for;

	for f in factorsOfBs do
		modu:=f[1];
		multiples:=f[2];
		case #multiples:
			when 1:
				j,sgn:=jFromI(multiples[1]);
				addCondition(~rems,~mods,modu,factor*sgn*bs[j]);

			when 2:
				if IsDivisibleBy(factor,modu) then
					Append(~rems,1);
					Append(~mods,modu);
				else
					j1,sgn1:=jFromI(multiples[1]);
					j2,sgn2:=jFromI(multiples[2]);

					addDoubleCondition(~rems,~mods,modu,factor,sgn1*bs[j1],sgn2*bs[j2]);
				end if;
		end case;
	end for;
	remainder:=goodCRT(rems,mods);
	return factor,remainder;
end function;

factorAndModCondQuint:=function(bs,factorsOfBs)
	factor:=R!1;
	rems:=[R|];
	mods:=[R|];
	for f in factorsOfBs do
		modu:=f[1];
		multiples:=f[2];
		assert #multiples le 2;
		if #multiples eq 2 and &and[i le 2: i in multiples] then
			factor*:=modu;
			Append(~mods,modu);
			Append(~rems,1);
		end if;
	end for;
			
	for f in factorsOfBs do
		modu:=f[1];
		multiples:=f[2];
		case #multiples:
			when 1:
				i:=multiples[1];
				if i le 2 then
					addCondition(~rems,~mods,modu,factor*bs[3-i]);
				else
					Append(~rems,1);
					Append(~mods,modu);
				end if;

			when 2:
				i:=Index([i le 2: i in multiples],true);
				if i eq 0 then
					addCondition(~rems,~mods,modu,factor*bs[12-&+multiples]);
				elif not &and[i le 2: i in multiples] then
					addCondition(~rems,~mods,modu,factor*bs[3-multiples[i]]);
				end if;
		end case;
	end for;
	
	rem:=goodCRT(rems,mods);
	return factor,rem;
end function;
			
randPolyWithCond:=function(g,rem,deg:noBound:=true)
	assert GreatestCommonDivisor(g,rem) eq 1;
	N:=deg+Degree(g);
	bound:=5*N;
	count:=0;
	repeat
		fact:=randPolyFF(deg:precise:=true);
		fact:=1/(LeadingCoefficient(fact)*LeadingCoefficient(g))*fact;
		output:=fact*g+rem;
		count+:=1;
	until IsPrime(output) or ((not noBound) and count gt bound);
	assert IsPrime(output);
	return output;
end function;

split:=function(bs,factorsOfBs,evenDegrees,oddDegrees)
	case #evenDegrees:
		when 0:
			Perm:=[];
			eps:=1;
		when 1:
			Perm:=threeToOne(bs,evenDegrees[1]);
			eps:=1;
		when 2:
			Perm,eps:=twoToTwo(bs,oddDegrees);
		when 3: 
			Perm:=threeToOne(bs,complement(evenDegrees,4)[1]);
			eps:=0;
		when 4:
			Perm:=[];
			eps:=0;
	end case;

	permHousekeeping(Perm,~bs,~factorsOfBs);

	factor,remainder:=factorAndModCond(bs,factorsOfBs);
	bprod:=&* bs;
	eps:=(eps + Degree(factor)) mod 2;
	a:=randPolyWithCond(bprod,remainder,3*Degree(bprod)+eps:noBound);

	return bs,Perm,factor*a;
end function;

splitQuintenary:=function(bs,factorsOfBs,evenDegrees)
	oddDegrees:=complement(evenDegrees,5);
	case #evenDegrees:
		when 0:
			Perm:=[];
			eps:=1;
		when 1:
			Perm:=[<3,evenDegrees[1]>];
			eps:=1;
		when 2:
			Perm:=threeToTwo(evenDegrees[1],evenDegrees[2]);
			eps:=0;
		when 3:
			Perm:=threeToTwo(oddDegrees[1],oddDegrees[2]);
			eps:=1;
		when 4:
			Perm:=[<3,oddDegrees[1]>];
			eps:=0;
		when 5:
			Perm:=[];
			eps:=0;
	end case;

	permHousekeeping(Perm,~bs,~factorsOfBs);

	factor,remainder:=factorAndModCondQuint(bs,factorsOfBs);
	bprod:=&* bs;

	eps:=(eps + Degree(factor)) mod 2;

	a:=randPolyWithCond(bprod,remainder,3*Degree(bprod)+eps);

	return bs,Perm,factor*a;
end function;

solFromSolMin:=function(sol,T)
	L:=Matrix([sol]);
	//printf "I'm in solFromSolMin. The transformation matrix that I've been given is \n%o \n, so its inverse is \n%o \n and I'm just about to adjust the solution.\n",T,T^(-1);
//	printf "The solution is %o, by the way.\n",sol;
	return ElementToSequence(L*T^(-1));
end function;

rearrangeSol:=function(Sol,Perms)
	for t in Reverse(Perms) do
		swap(t[1],t[2],~Sol);
	end for;
	return Sol;
end function;

quaternaryFormIsMinimised:=function(as)
	Fas:=[Factorisation(a): a in as];
	if &or[&or[fact[2] ge 2: fact in F]: F in Fas] then
		//print "someone is not squarefree";
		return false;
	end if;
	F:=jointFactoTransfo(Fas);
	for fact in F do
		if #fact[2] gt 3 then
			//print "The discriminant is not cube free";
			return false;
		end if;
		if #fact[2] eq 2 and JacobiSymbol(-&*[as[i]: i in complement(fact[2],4)],fact[1]) ne 1 then
			//print "condition 3 is unverified";
			return false;
		end if;
	end for;
	return #[a: a in as | IsSquare(LeadingCoefficient(a))] ge 2;
end function;

conicSolvableAtG:=function(as,g)
	v:=[Valuation(a,g): a in as];
	pv:=[val mod 2: val in v];
	case #[p : p in pv | p eq 0]:
		when 0:
			return true;
		when 3:
			return true;
		when 1:
			j:=Index(pv,0);
		when 2:
			j:=Index(pv,1);
	end case;
	return JacobiSymbol(-&*[a: i->a in as | i ne j] div g^(&+[va : i->va in v | i ne j]),g) eq 1;
end function;

locallyTestTheSplit:=procedure(bs,f)
	bs1:=bs[1..2] cat [-f];
	bs2:=bs[3..4] cat [f];
	Ff:=Factorisation(f);
	fbs:=[Factorisation(b): b in bs];
	for facto in fbs do
		for c in facto do
			if not conicSolvableAtG(bs1,c[1]) then
				//printf "The first conic is not solvable at %o.\n",c[1];
			end if;	
			if not conicSolvableAtG(bs2,c[1]) then
				//printf "The second conic is not solvable at %o.\n",c[1];
			end if;	
		end for;
	end for;
	for c in Ff do
		if not conicSolvableAtG(bs1,c[1]) then
			//printf "The first conic is not solvable at %o.\n",c[1];
		end if;	
		if not conicSolvableAtG(bs2,c[1]) then
			//printf "The second conic is not solvable at %o.\n",c[1];
		end if;	
	end for;
end procedure;
		
solveTernaryForm:=function(bs)
	C:=Conic([K!b: b in bs]);
	SolExists,P:=HasRationalPoint(C);
	if SolExists then
		return true,eval"Coordinates(P)";
	end if;
	return false,[];
end function;

affineCoords:=function(L)
	n:=#L;
	return [L[i]/L[n]: i in [1..n-1]];
end function;

solveQuaternaryForm:=function(as);	
	bs,T,FactorsOfBs:=minimiseQuaternary(as);
	//printf "Checking that our form is correctly minimised, we get %o.\n",quaternaryFormIsMinimised(bs);
	if &and[Degree(b) eq 0: b in bs] then
		return solveConstantForm(bs);
	end if;
	EvenDegrees,OddDegrees:=evensAndOdds(bs);
	assert isIsotropicAtInfinity(bs,EvenDegrees,OddDegrees);
	Solved,Sol,i,j:=checkBinaries(bs);
	if Solved then
		S:=[K!0: _ in [1..4]];
		S[i]:=Sol[1];
		S[j]:=Sol[2];
		return solFromSolMin(S,T);
	end if;
	bs,Perms,f:=split(bs,FactorsOfBs,EvenDegrees,OddDegrees);
	//printf "According to the output of splitm fsgs*a = %o.\n",f;
	//locallyTestTheSplit(bs,f);
	_,Coords1:=solveTernaryForm(bs[1..2] cat [-f]);
	Sol1:=affineCoords(Coords1);
	_,Coords2:=solveTernaryForm(bs[3..4] cat [f]);
	Sol2:=affineCoords(Coords2);
	Sol:=Sol1 cat Sol2;
	Sol:=rearrangeSol(Sol,Perms);
	return solFromSolMin(Sol,T);
end function;	

solveQuintenaryForm:=function(as)
	bs,T,factorsOfBs:=minimiseQuintenary(as);
	EvenDegrees:=[i: i->b in bs | IsEven(Degree(b))];
	bs,Perms,f:=splitQuintenary(bs,factorsOfBs,EvenDegrees);

	SolExists1,Sol:=solveBinaryForm([b: b in bs[1..2]]);
	if SolExists1 then
		Sol:=rearrangeSol(eval "Sol cat [0,0,0]",Perms);
		return solFromSolMin(Sol,T);
	end if;

	SolExists2,Sol:=solveTernaryForm(bs[3..5]);
	if SolExists2 then
		Sol:=rearrangeSol(eval "[0,0] cat Sol",Perms);
		return solFromSolMin(Sol,T);
	end if;

	_,Coords1:=solveTernaryForm(bs[1..2] cat [-f]);
	Sol1:=affineCoords(Coords1);

	Coords2:=solveQuaternaryForm(bs[3..5] cat [f]);
	Sol2:=affineCoords(Coords2);

	Sol:=Sol1 cat Sol2;
	Sol:=rearrangeSol(Sol,Perms);
	return solFromSolMin(Sol,T);
end function;	

diagonalizeForm:=function(M);
	V:=QuadraticSpace(M);
	B:=SemiOrthogonalBasis(V);
	return [QuadraticNorm(e): e in B],Matrix([Coordinates(V,e): e in B]);
end function;

/*Input is the matrix of a quadratic form*/
zeroQuadraticForm:=function(M)
	D,T:=diagonalizeForm(M);
	k:=lcmList(denominatorsList(D));
	D:=[k*d: d in D];
	case #D:
		when 1:
			Sol:=[0];
		when 2:
			Sol:=solveBinaryForm(D);
		when 3:
			Sol:=solveTernaryForm(D);	
		when 4:
			Sol:=solveQuaternaryForm(D);
		else
			Sol:=solveQuintenaryForm(D[1..5]);
	end case;
	goodSol:=Matrix([Sol cat [0: _ in [6..#D]]])*T;
	return ElementToSequence(goodSol);
end function;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//					Split 2x2 matrix algebra over Kext [5]					//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

quaternionBasis:=function(A:u:=0)
	if u eq 0 then
		u:=Basis(A)[Index([a in Kext : a in Basis(A)], false)];
		u:=u-Trace(u)/4;
		if u^2 eq 0 then
			return true,[u];
		end if;
	end if;
	LHS:=Matrix([Coordinates(A,u*b+b*u): b in Basis(A)]);
	v:=A!ElementToSequence(Basis(Nullspace(LHS))[1]);
	if v^2 eq 0 then
		return true,[v];
	end if;
	return false,[One(A),u,v,u*v];
end function;

nonCentralRationalSquare:=function(B)
	Lu:=ElementToSequence(Kext!(B[2]^2));
	Lv:=ElementToSequence(Kext!(B[3]^2));
	r1:=Lu[1];
	t1:=Lu[2];
	r2:=Lv[1];
	t2:=Lv[2];
	Q:=Matrix(SparseMatrix(K,6,6,[<1,1,t1>,<2,2,t1*D>,<1,2,2*r1>,<3,3,t2>,<4,4,t2*D>,<3,4,2*r2>,<5,5,-(r1*t2 + t1*r2)>,<6,6,-(r1*t2 + t1*r2)*D>,<5,6,-2*(r1*r2+t1*t2)>]));
	Sol:=zeroQuadraticForm(Q);
	Sol:=[Sol[i]+Sol[i+1]*t: i in [1..6 by 2]];
	return &+[Sol[i]*e: i->e in B[2..4]];
end function;

/*Input: A quaternionic basis [1,u,v,uv] such that u^2 in K.*/
anticommRatSquare:=function(B)
	a:=K!(B[2]^2);
	a2:=Kext!(B[3]^2);
	L:=ElementToSequence(a2);
	b:=L[1];
	c:=L[2];
	d:=D;
	Q:=Matrix(SparseMatrix(K,4,4,[<1,1,c>,<2,2,c*d>,<1,2,2*b>,<3,3,-a*c>,<4,4,-a*c*d>,<3,4,-2*a*b>]));
	Sol:=zeroQuadraticForm(Q);
	v:=(Sol[1]+Sol[2]*t)*B[3] + (Sol[3]+Sol[4]*t)*B[4];
	return [B[1],B[2],v,B[2]*v];
end function;

findZeroDivQuatOverKext:=function(A);
	foundZero,B:=quaternionBasis(A);
	if foundZero then 
		return B[1];
	end if;
	u:=nonCentralRationalSquare(B);
	foundZero,B:=quaternionBasis(A:u:=u);
	if foundZero then
		return B[1];
	end if;

	B:=anticommRatSquare(B);
	a:=B[2]^2;
	b:=B[3]^2;
	
	if b^2 eq 0 then
		return B[3];
	end if;

	C:=QuaternionAlgebra<K | a,b>;
	isSplit,_,f:=IsMatrixRing(C:Isomorphism:=true);
	if isSplit then
		zeroDiv:=Matrix(K,[[1,0],[0,0]]) @@ f;
		return &+[zeroDiv[i]*b: i->b in B];
	end if;
	x:=zeroQuadraticForm(DiagonalMatrix(K,[a,b,-a*b,-D]));
	return &+[x[i]/x[4] * b: i->b in B[2..4]] - t;
end function;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//				Splitting an algebra of the form M2(D) [6, theorem 18]				//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*Returns a list of length d containing the d lowest degree (possibly zero) coefficients of P*/
coefficientsUpTo:=function(P,d)
	if P eq 0 then
		return [0: _ in [1..d]];
	end if;
	return (Coefficients(P) cat [0: _ in [0..d-Degree(P)]])[1..d];
end function;

/*applies the previous function to a list of polynomials*/
explodeCoeffs:=function(L,d)
	return &cat[coefficientsUpTo(p,d): p in L];
end function;

/*Inverse operation to explodeCoeffs*/
regroupCoeffs:=function(L,d)
	lL:=#L;
	assert IsDivisibleBy(lL,d);
	return [R!L[i..i+d-1]: i in [1..lL by d]];
end function;

/*Returns the Fq-algebra O/gO for g in Fq[X]*/
quotient:=function(O,g)
	d:=Degree(g);
	SC:=[[&cat[coefficientsUpTo(R!((X^(k+l))*r) mod R!g,d): r in ElementToSequence(O!(z*y))]: k in [0..d-1], y in Basis(O)]: l in [0..d-1], z in Basis(O)];
	B:=AssociativeAlgebra<F,Dimension(O)*d|SC: Check:=false>;
	f:=map<O -> B | r:->B!explodeCoeffs(ElementToSequence(r),d), y:->O!regroupCoeffs(Coordinates(B,y),d)>;
	return B,f;
end function;

localIndex:=function(O,f)
	assert IsPrime(f);
	B:=quotient(O,f);
	J:=JacobsonRadical(B);
	C:=quo<B | J>;
	Z:=Center(C);
	return ExactQuotient(Dimension(Z),Degree(f));
end function;

//O is a maximal order in A isomorphic to M2(B), with B a quaternion algebra over K.
//Outputs the list of finite primes at which B ramifies
ramificationsWhere:=function(O)
	toTest:=[f[1]: f in Factorisation(Discriminant(O))];
	ramifiedPrimes:=[];
	for f in toTest do
		if localIndex(O,f) gt 1 then
			Append(~ramifiedPrimes,f);
		end if;
	end for;
	return ramifiedPrimes;
end function;

//if B is the basis of quaternion algebra A, gives the index of the matrix B[k]*Ei,j in the basis of M2(A)
indicesToBasis:=function(i,j,k)
	return k+(j-1)*4+(i-1)*8;
end function;

basisToIndices:=function(n)
	k:=(n mod 4);
	k:= k eq 0 select 4 else k;
	n:=ExactQuotient(n-k,4);
	j:=(n mod 2) + 1;
	i:=ExactQuotient(n-j+1,2) + 1;
	return i,j,k;
end function;

basisProductM2A:=function(i1,j1,k1,i2,j2,k2,A)
	Result:=[K| 0: _ in [1..16]];
	if j1 ne i2 then
		return Result;
	end if;
	
	B:=Basis(A);
	prod:=ElementToSequence(B[k1]*B[k2]);
	
	for k->c in prod do
		Result[indicesToBasis(i1,j2,k)]:=c;
	end for;
	return Result;
end function;

matrixAlgebraOverAlg:=function(A:Ofi:=0,Oinf:=0)
	B:=Basis(A);
	SC:=[[basisProductM2A(i1,j1,k1,i2,j2,k2,A): k2 in [1..4], i2,j2 in [1..2]]: k1 in [1..4], i1,j1 in [1..2]];
	M:=AssociativeAlgebra<K, 16 | SC: Check:=false>;
	
	if Ofi cmpeq 0 then
		Ofi:=MaximalOrderFinite(A);
	end if;
	
	if Oinf cmpeq 0 then
		Oinf:=MaximalOrderInfinite(A);
	end if;

	MOfi:=Order(R,[M!(&cat[[0: _ in [1..i]],Coordinates(A,b),[0: _ in [i+5..16]]]): b in Basis(Ofi), i in [0..12 by 4]]);
	MOinf:=Order(P,[M!(&cat[[0: _ in [1..i]],Coordinates(A,b),[0: _ in [i+5..16]]]): b in Basis(Oinf), i in [0..12 by 4]]);
	return M,MOfi,MOinf;
end function;

//v is an element of a left A-module V, and f is the canonical map from A to GL(V)
rankOfModuleElement:=function(A,f,v,V,T)
	W:=sub<V | [V!((a @ f)*(T!v)): a in Basis(A)]>;
	return Dimension(W);
end function;

enumPolys:=function(N)
	T:=CartesianPower(F,N);
	return ([R![x: x in t]: t in T]);
end function;

genOmega:=function(ohm)
	omega:=[];
	d:=Ceiling(Log(p,ohm+1));
	return enumPolys(d);
end function;

incrCouple:=function(i,j,ohm,n)
	i+:=1;
	if i gt ohm then
		i:=1;
		j+:=1;
	end if;
	assert j le n;
	return i,j;
end function;

findCyclicModuleGenerator:=function(A,fA,V,d,T,extraCond:B:=0,fB:=0,v:=0)
	ohm:=extraCond select 2*d+1 else d+1;
	if not extraCond then
		v:=V!0;
	end if;
	omega:=genOmega(ohm);
	r:=rankOfModuleElement(A,fA,v,V,T);
	while not r eq d do
		i:=1;
		j:=1;
		repeat
			w:=v+omega[i]*BasisElement(V,j);
			i,j:=incrCouple(i,j,ohm,d);
			rw:=rankOfModuleElement(A,fA,w,V,T);
		until rw gt r and ((not extraCond) or rankOfModuleElement(B,fB,w,V,T) eq d);
		r:=rw;
		v:=w;
	end while;
	return v;
end function;
	
//T is the tensor product of A and B, with B isomorphic to A^op. phiA and phiB are respective injections of A and B in T, and e is a rank one idempotent element of T.
//This function outputs an isomorphism from A to Bop.
fromSplitToIsom:=function(A,B,phiA,phiB,T,e)
	d:=Dimension(A);
	assert d eq Dimension(B);
	L:=BaseField(A);
	W:=Module(T);
	V:=sub<W | [W!(t*e): t in Basis(T)]>;

	v:=findCyclicModuleGenerator(A,phiA,V,d,T,false);
	v:=findCyclicModuleGenerator(B,phiB,V,d,v,T,true:B:=A,fB:=phiA,v:=v);

	phiV:=hom<A -> V | [(a @ phiA)*v: a in Basis(A)]>;
	psiV:=hom<B -> V | [(b @ phiB)*v: b in Basis(B)]>;

	return phiV * Inverse(psiV);
end function;

zeroDivInM2D:=function(A,ramifications:Ofi:=0,Oinf:=0)
	if Ofi cmpeq 0 then
		Ofi:=MaximalOrderFinite(A);
	else
		Ofi:=MaximalOrder(Ofi);
	end if;
	
	if Oinf cmpeq 0 then
		Oinf:=MaximalOrderInfinite(A);
	else
		Oinf:=MaximalOrder(Oinf);
	end if;

	N:=&*ramifications;
	D:=AssociativeAlgebra(QuaternionAlgebra(N));
	M2D,OfiM2D,OinfM2D:=matrixAlgebraOverAlg(D);
	
	T,phiA,phiM2D,_,OfiT,OinfT:=tensorProduct(A,M2D:Ofis:=[Ofi,OfiM2D],Oinfs:=[Oinf,OinfM2D]);
	e:=rankOneIdempotent(T:Ofi:=OfiT,Oinf:=OinfT);

	phi:=fromSplitToIsom(A,M2D,phiA,phiM2D,T,e);
	return BasisElement(M2D,1) @@ phi;
end function;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//						Main task							//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
leftUnit:=function(I)
	k:=BaseField(I);
	LHS:=Matrix(k,[&cat[Coordinates(I,i*x): x in Basis(I)]: i in Basis(I)]);
	RHS:=Matrix(k,[ElementToSequence(ScalarMatrix(Dimension(I),k!1))]);
	e:=I!ElementToSequence(Solution(LHS,RHS));

	return e;
end function;
	
zeroDivToIdempotent:=function(A,z)
	_,r:=IsSquare(Dimension(A));
	I:=rideal<A | z>;
	return A!leftUnit(I),ExactQuotient(Dimension(I),r);
end function;

zeroDivToRankOneIdempotent:=function(A,z)
	e,rank:=zeroDivToIdempotent(A,z);
	printf "We have a zero divisor of rank %o. We will use it to find a rank one idempotent.\n",rank;
	case rank:
		when 1:
			return e;
		when 3:
			return 1-e;
		when 2:
			B:=sub<A | [e*a*e: a in Basis(A)]>;
			z:=findZeroDivQuatOverKext(B);
			e:=zeroDivToIdempotent(B,z);
			return A!e;
	end case;
end function;

main:=function(B1,B2)
	Ofis:=[MaximalOrderFinite(B1),MaximalOrderFinite(B2)];
	Oinfs:=[MaximalOrderInfinite(B1),MaximalOrderInfinite(B2)];
	A,phi1,phi2,invo1stKind,Ofi,Oinf:=tensorProduct(B1,B2:quats:=true,Ofis:=Ofis,Oinfs:=Oinfs);

	print "We have computed the tensor product A of B1 and B2, and now we approach the computational bottleneck:";
	print "We will compute the corestriction of A and compute an explicit isomorphism from it to a matrix algebra.";
	zeroDiv,invo2ndKind:=invSec(A:Ofi:=Ofi,Oinf:=Oinf);

	if zeroDiv eq 0 then
		print "We found an involution of the second kind over A.";

		print "Here we print the image of the basis elements of A by this involution.";
		print "For each element a, we print the image of a and that of t*a.";
		for a in Basis(A) do
			print a @ invo2ndKind;
			print (t*a) @ invo2ndKind;
		end for;

		twistedAction:=invo1stKind * invo2ndKind;
		V,f:=restrictScalarsVS(A);

		AK,goUp,OfiAK,OinfAK:=descendAlgebra(A,f,Ofi,Oinf,Inverse(f) * twistedAction * f);
		
		ramifiedFinitePlaces:=ramificationsWhere(AK);
		print "Using our involutions, we found a K-subalgebra of A, we call it AK.";
		if ramifiedFinitePlaces eq [] then
			print "AK happens to be split. We find a rank one idempotent and send it back up!";
			e:=rankOneIdempotent(A:Ofi:=OfiAK,Oinf:=OinfAK);
			e := e @ goUp;
			return fromSplitToIsom(B1,B2,phi1,phi2,A,e) * stdInv(B2);
		end if;
		printf "AK is not split: it ramifies at the following primes: %o.\n",ramifiedFinitePlaces;
		zeroDiv:=zeroDivInM2D(AK,ramifiedFinitePlaces:Ofi:=OfiAK,Oinf:=OinfAK) @ goUp;
		print "We found a zero divisor in AK, which we sent back up to A.";
	else
		print "From the splitting of the corestriction of A, we directly found a zero divisor in A.";
	end if;

	print "Our zeroDivisor in A is the following element:";
	print zeroDiv;
	
	e:=zeroDivToRankOneIdempotent(A,zeroDiv);
	return fromSplitToIsom(B1,B2,phi1,phi2,A,e) * stdInv(B2);
end function;
			
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//						Testing area							//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//								Bibliography:												//
//	[1] A. K. Lenstra - Factoring Multivariate Polynomials over Finite Fields, 1984											//
//	[2] G. Ivanyos, P. Kutas, L. Rnyai - Computing Explicit Isomorphisms with Full Matrix Algebras over Fq(x), 2018						//
//	[3] L.Rnyai - 	Computing the Structure of Finite Algebras, 1990												//
//	[4] W.A de Graaf, G. Ivanyos, A. Kronya, L.Rnyai - Computing Levi Decompositions in Lie algebras, 1997							//
//	[5] G.Ivanyos, P.Kutas, L.Rnyai - Explicit equivalence of quadratic forms over Fq(t), 2018									//
//	[6] J.Gmez-Torrecillas, P.Kutas, F.J.Lobillo, G.Navarro - Primitive idempotents in central simple algebras over Fq(T) with applications to coding theory	//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
